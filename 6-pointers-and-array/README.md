# 포인터와 배열

포인터와 배열에 대해 알아보고, 변수를 입력받는 방법에 대해 배웁니다.

## 메모리 주소(memory address)

[2장](../2-structure-of-computers)에서 메모리는 책장처럼 생긴 장치이고, 책장의 각 공간엔 밑에서부터 차례대로 번호가 붙어있다고 했었습니다. 이 번호를 실제로는 `메모리 주소(memory address)`라고 합니다. C에선 이 메모리 주소에 대해 덧셈과 뺄셈을 할 수 있는 기능을 제공하는데요, 이 때 `포인터(pointer)`라고 하는 자료형이 사용됩니다. 포인터는 메모리 주소를 담고 있는 자료형입니다. 즉, 일단 수학적으로 봤을 때 들어있는 형태는 정수입니다. 예를 들어 `int a`가 주소 36\~39를 차지하고 있다고 해봅시다. 그럼 포인터를 하나 만들고, 거기에 `int a`를 저장하는 공간의 가장 밑부분인 `36`을 그 포인터에 저장할 수 있습니다. 이 메모리 주소에 원하는 정수를 더하거나 빼는 것도 가능합니다.

## 포인터 선언하기

포인터 변수는 변수를 선언할 때, 변수 앞에 `*`를 붙여서 선언할 수 있습니다.

> 별표`*`는 사실 `애스터리스크(asterisk)`라는 이름이 있는데요, 다들 별표나 star라고 부릅니다.

```c
int main()
{
    int i = 5;
    int *p;
    p = &i;
}
```
변수 `i`는 지금까지 써 왔던 변수와 똑같습니다. 반면에, 변수 `p`는 선언할 때 앞에 `*`을 붙였기 때문에 포인터가 됩니다. 이 예제에서 알 수 있는 것은 여러가지인데요, 

* `p = &i`라는 식을 통해 `&`가 변수의 주소를 반환하는 단항 연산자임을 알 수 있습니다.
* 포인터를 선언할 땐 항상 어떤 자료형의 변수의 주소를 담을 건지 명시해야함을 알 수 있습니다.
* `*`가 변수의 선언에서 변수의 이름 앞에 붙으면 포인터임을 나타내는 표시가 된다는 것을 알 수 있습니다. `*`가 곱하기 말고도 여러 역할을 하는 것처럼, C에선 모양은 같지만 역할은 다른 경우가 여러가지 있습니다.

이 때 포인터 `p`의 자료형을 `int *`이라고 하는데요, 이 자료형을 풀어서 `int를 가리키는 포인터(a pointer to an integer)`라고도 합니다.

> `int`와 `*`은 다른 토큰으로 분리될 수 있기 때문에 `int* p` 라고 적어도 `p`가 포인터가 됩니다.

> `&`는 `주소 연산자(Address-of operator)`라고 불립니다.

그럼 이 예제를 사람들이 쓰는 말에 가깝게 쓰면
```
프로그램이 시작했을 때,
    적당한 공간을 i라고 이름 짓고 정수 5를 넣습니다.
    적당한 공간을 p라고 이름 짓습니다.
    p라는 이름의 공간에 i의 주소를 담습니다.
```
가 됩니다. 즉, i가 48\~51번을 차지하고 있다면 p에는 48이 들어있게 됩니다.

> 포인터가 가리키는 자료형이 `float`이나 `double`이라고 하더라도 포인터는 메모리 주소를 담는 자료형이기 때문에 항상 정수를 담습니다. 이 때문에 포인터는 어떤 자료형을 가리키든간에 항상 같은 크기를 가지는데요, 보통 4바이트 또는 8바이트의 크기를 가집니다. 이것에 대해서는 나중에 자세히 다루도록 하겠습니다.

변수를 한 번에 여러 번 선언할 수 있는 것처럼, 포인터도 한 번에 여러 번 선언할 수 있습니다.
```c
int main()
{
    int *p, i = 5, *q = &i;
}
```
여기서 `p`와 `q`는 포인터이고, `i`는 그냥 자료형이 `int`인 변수입니다. 포인터 `p`는 초시식이 없기 때문에 어떤 값이 들어있는지 모르고, `q`는 초기식 `&i`가 주어졌기 때문에 `i`의 주소값을 갖게 됩니다.

## 포인터를 이용한 참조

[4장](../4-types-and-variables)에서 메모리 주소로만 프로그래밍을 하면 큰 프로그램을 개발하기 힘들어지기 때문에 변수라는 것이 생겼다는 설명을 했습니다. 여기서 특정한 메모리 공간에 값을 불러오고 계산한 후 다시 넣는 것을 변수라는 도구로 **추상화**할 수 있음을 배웠습니다. 포인터는 메모리 주소를 직접적으로 다룰 수 있는 도구입니다. 다시 말해, 메모리 공간에 들어있는 값을 넣고 빼고 계산할 수 있는 작업을 포인터로도 할 수 있습니다.
```c
#include <stdio.h>

int main()
{
    int i = 5;
    int *p;
    p = &i;
    *p = 6;
    printf("%d ", i);
    printf("%d", *p + 7);
}
```
```
6 13
```
여기서 `int *p;`와 `p = &i;`를 지우고, `*p`를 `i`로 교체해도 결과는 같습니다. 즉, `*p`가 `i`를 대체할 수 있는 것입니다. 이렇게 `*`은 곱셈 이항 연산자가 아니라 단항 연산자로 쓰였을 때, 포인터가 원래 가리키고 있는 변수를 가져올 수 있게 해주는 역할을 합니다. 이 예제를 컴파일했을 때 `i`가 64\~67번을, `p`가 68\~71번을 차지하고 있다고 가정해봅시다. 그럼 이 프로그램을 사람이 하는 말에 가깝게 옮기면,

| 문장 | 설명 | 실행 후 메모리 상태 |
| --- | --- | --- |
| `int i = 5;` | 64번을 `i`라고 이름 짓고, `i`라는 이름의 공간에 `5`를 넣습니다. | !["Memory 1"](img/1.png "Memory 1") |
| `int *p;` | 68번을 `p`라고 이름 짓습니다. | !["Memory 2"](img/2.png "Memory 2") |
| `p = &i;` | `p`라는 이름의 공간에 `i`라는 이름의 공간의 메모리 주소를 넣습니다. | !["Memory 3"](img/3.png "Memory 3") |
| `*p = 6;` | `p`라는 이름의 공간에 들어있는 메모리 주소를 가지는 공간에 `6`을 넣습니다. | !["Memory 4"](img/4.png "Memory 4") |
| `printf("%d ", i);` | `i`라는 이름의 공간에 들어있는 값을 출력합니다. (6 출력) | !["Memory 4"](img/4.png "Memory 4") |
| `printf("%d", *p + 7)` | `p`라는 이름의 공간에 들어있는 메모리 주소를 가지는 공간에 들어있는 값에 7을 더한 값을 출력합니다. (13 출력) | !["Memory 4"](img/4.png "Memory 4") |

이렇게 해석될 수 있습니다. 각 문장의 설명과 실행 후 메모리 상태를 유심히 봐주세요.

> `*`은 `간접 참조 연산자(indirection operator)`라고 불립니다.

## 좌측값(lvalue)와 우측값(rvalue)

지금까지의 예제에선 대입 연산자의 좌항엔 항상 변수가 들어갔습니다. [5장](../5-basic-operators)에서 대입 연산자에서 자주 나오는 실수들에 대해 다뤘을 때, `a + 1 = 5`에서 `a + 1`이 주소를 가지는 변수가 아니기 때문에 대입 연산자의 좌항에 나오지 못한다고 설명했지만, 방금 위의 예제에선 변수가 아닌 식 `*p`가 대입 연산자의 왼쪽에 들어갔습니다. 그런데, `a`, `a + 1`, `*p` 모두 자료형은 `int`로, 자료형에는 차이가 없습니다. 그럼 C 컴파일러는 대입 연산자의 왼쪽에 올 수 있는 식을 어떻게 구분할까요?

C에선 식이 가질 수 있는 값을 `좌측값(lvalue)`과 `우측값(rvalue)`로 구분합니다. 좌측값은 그 값을 담고 있는 메모리 주소를 알 수 있는 값입니다. 예를 들어, 변수 `i`가 `5`라는 값을 가지고 있을 때, 식 `i`는 결과값이 `5`인 좌측값입니다. 즉, `5`가 담겨있는 메모리 주소를 알 수 있습니다. 마찬가지로, 변수 `p`가 `i`의 주소값을 가지는 포인터라면, 식 `*p`는 결과값이 `5`인 좌측값입니다. 포인터 `p`는 그 자체로도 변수이기 때문에, 식 `p`는 결과값이 `i`의 주소인 좌측값입니다. 반대로 식 `i + 1`은 결과값이 `6`이지만, 좌측값은 아닙니다. 마찬가지로, 식 `*p * 6`은 결과값이 `30`이지만, 좌측값은 아닙니다. 이렇게 좌측값이 아닌 값들을 우측값이라고 합니다.

대입 연산자의 왼쪽에 들어갈 수 있는 값은 바로 좌측값들입니다. 좌측값이라는 이름은 대입 연산자의 왼쪽에서 올 수 있다는 특징에서 유래했습니다. 마찬가지로 단항 연산자 `&`를 적용할 수 있는 식들은 결과값이 좌측값이어야 합니다. 다시 말해, `&(i + 1)`은 잘못된 식이지만, `&*p`는 올바른 식입니다.

> 여기서 `~의 결과값은`이란 표현은 제가 `~ is evaluated as`라는 표현을 번역한 것입니다.

> C++ 표준에선 식이 가질 수 있는 값을 lvalue, prvalue, xvalue, glvalue, rvalue 다섯가지로 구분합니다. 이것과 관련된 정확한 구분은 C++에 대해 배울 때 다루겠습니다.

다음 코드를 Visual Studio 에디터에 입력해주세요.
```c
int main()
{
    int a = 4;
    a + 1 = 5;
}
```

`a`에 빨간줄이 뜨면서 에디터에서 에러 메시지를 표시하는 것을 확인할 수 있습니다.

!["lvalue-related error"](img/5.png "lvalue-related error")

"expression must be a modifiable lvalue", 즉 "표현식이 수정 가능한 좌측값이어야 합니다"입니다. 실제로 `Ctrl + F5`를 눌러 실행해보려고 하면 컴파일러가 비슷한 메시지와 함께 에러를 표시하는 것을 확인할 수 있습니다.