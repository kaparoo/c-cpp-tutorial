# 제어 흐름과 함수

프로그램의 실행을 제어할 수 있는 방법인 조건문, 반복문, 함수에 대해 다루고, 그 기능들을 사용하기 위한 개념들을 배웁니다.

## 불 대수(boolean algebra)

불 대수는 논리학에서 `진리값(truth value)`, 즉 `참`과 `거짓`을 `1`과 `0`에 대응시키고, 이것에 대한 연산을 덧셈과 곱셈으로 바꾼 대수 체계입니다. 불 대수의 덧셈과 곱셈은 다음 성질을 만족합니다.

| `a` | `b` | `a + b` |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

| `a` | `b` | `a × b` |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

여기서 `1 + 1 = 1`이 되는 것을 제외하면 우리가 아는 덧셈, 곱셈과 큰 차이가 나지 않는 것을 알 수 있습니다. 여기서의 덧셈을 `논리합(logical disjunction)` 또는 `OR 연산`, 곱셈을 `논리곱(logical conjunction)` 또는 `AND 연산`이라고 부릅니다. `또는`과 `그리고`라는 이름으로 불리는 이유는 0을 거짓, 1을 참으로 교체해보면 쉽게 알 수 있습니다.

불 대수에선 이것 말고도 `부정(negation)` 또는 `NOT 연산`이라고 불리는 연산이 있습니다.

| `a` | `¬a` |
| --- | --- |
| 0 | 1 |
| 1 | 0 |

참을 거짓으로, 거짓을 참으로 바꿔주는 연산입니다. 이외에도 여러 연산이 있지만, 나중에 다루도록 하겠습니다.

> 불 대수의 덧셈과 곱셈은 교환법칙과 결합법칙 분배법칙이 모두 성립합니다. 즉, 다음 성질을 모두 만족합니다.
>
> * `a + b = b + a`
> * `a × b = b × a`
> * `a + (b + c) = (a + b) + c`
> * `a × (b × c) = (a × b) × c`
> * `c(a + b) = ca + cb`
>
> 또 `드 모르간의 법칙(De Morgan's laws)`은 불 대수에서도 성립합니다.
>
> * `¬(a + b) = ¬a × ¬b`
> * `¬(a × b) = ¬a + ¬b`

## 논리 연산자(logical operator)

위에서 배운 세 연산은 모두 C에서 연산자로 사용할 수 있습니다. 아쉽게도, 위에서 사용한 연산자와 모양이 다릅니다. C에서 논리합은 `||`, 논리곱은 `&&`, 부정은 `!` 연산자를 사용합니다.

> `|`라는 기호는 `바(bar)`라는 이름이 있습니다.

```c
#include <stdio.h>

int main()
{
    printf("%d || %d = %d\n", 0, 0, 0 || 0);
    printf("%d || %d = %d\n", 0, 1, 0 || 1);
    printf("%d || %d = %d\n", 1, 0, 1 || 0);
    printf("%d || %d = %d\n", 1, 1, 1 || 1);
    printf("\n");
    printf("%d && %d = %d\n", 0, 0, 0 && 0);
    printf("%d && %d = %d\n", 0, 1, 0 && 1);
    printf("%d && %d = %d\n", 1, 0, 1 && 0);
    printf("%d && %d = %d\n", 1, 1, 1 && 1);
    printf("\n");
    printf("!%d = %d", 0, !0);
    printf("!%d = %d", 1, !1);
}
```
```
0 || 0 = 0
0 || 1 = 1
1 || 0 = 1
1 || 1 = 1

0 && 0 = 0
0 && 1 = 0
1 && 0 = 0
1 && 1 = 1

!0 = 1
!1 = 0

```

> `printf`에서 `\n`을 사용하면 줄바꿈을 할 수 있게 됩니다. 이것에 대한 자세한 설명은 나중에 문자열에 대해 다룰 때 하겠습니다.

C를 포함한 대부분의 프로그래밍 언어에선 어떤 값을 논리값으로 사용하게 되면, `0`을 거짓으로, `0`을 제외한 모든 값을 참으로 취급합니다. 따라서 위의 예제에서 `1`을 `2`나 `(-5)`같은 다른 값으로 바꿔도 논리 연산자의 결과값은 같습니다.

`&&` 연산자는 `||`보다 우선 순위가 높습니다(`&&`는 논리**곱** 연산자). 그래서 `1 || 2 && 5`는 `1 || (2 && 5)`로 번역됩니다. `!` 연산자는 형변환 연산자나 `sizeof` 연산자처럼 산술 연산자보다 우선순위가 높습니다. 그래서 `!1 + 5`는 `(!1) + 5`가 되어 결과값이 `5`가 됩니다.

## 단락 평가(short-circuit evaluation)

> 이 강좌에서 `~의 결과값`은 `~ is evaluated as`를 번역한 것입니다.

이항 논리 연산자들은 항상 좌항의 결과값을 먼저 계산(evaluation)하고, 우항의 결과값을 계산합니다. 그런데 만약 논리합 연산자에서 좌항이 1이거나, 논리곱 연산자에서 좌항이 0이라면, 불 대수의 다음 성질에 의해, 우항을 계산할 필요가 없어집니다.

* `a + 1 = 1`
* `a × 0 = 0`

우항의 결과가 참이든 거짓이든 항상 결과값이 같기 때문입니다. C에선 성능을 위해 이런 경우 우항을 계산하지 않습니다. 이런 기능을 `단락 평가(short-circuit evaluation)`이라고 합니다. 그런데 단락 평가는 예상치 못한 결과를 냅니다.

```c
#include <stdio.h>

int main()
{
    int i = 3, j;
    j = 1 || (i = 5);
    printf("%d %d", i, j);
}
```
```
3 1
```

`(i = 5)`를 통해 `i`에 `5`를 집어넣었음에도 불구하고, 값을 출력하면 `3`이 표시됩니다. 이것은 논리합 연산자의 좌항이 참이었기 때문에, `(i = 5)`가 실행되지 않았기 때문입니다.

```c
#include <stdio.h>

int main()
{
    int i = 3, j;
    j = (1 == 2) && (i = 5);
    printf("%d %d", i, j);
}
```
```
3 0
```

논리곱 연산자에서도 마찬가지로 좌항의 결과가 거짓이라면 우항을 실제로 실행하지 않습니다.

## 비교 연산자(comparison operator)

`비교 연산자(comparison operator; relational operator)`는 두 수를 비교하여 결과가 **진리값**이 되는 이항 연산자들입니다. 총 여섯가지의 비교 연산자들이 있습니다.

> C++20에선 비교 연산자가 하나 더 추가되었습니다. 나중에 다룰 예정입니다.

```c
#include <stdio.h>

int main()
{
    printf("%d %d %d\n", 3 <  5, 4 <  4, 6 <  5);
    printf("%d %d %d\n", 3 <= 5, 4 <= 4, 6 <= 5);
    printf("%d %d %d\n", 3 >  5, 4 >  4, 6 >  5);
    printf("%d %d %d\n", 3 >= 5, 4 >= 4, 6 >= 5);
    printf("%d %d %d\n", 3 == 5, 4 == 4, 6 == 5);
    printf("%d %d %d\n", 3 != 5, 4 != 4, 6 != 5);
}
```
```
1 0 0
1 1 0
0 0 1
0 1 1
0 1 0
1 0 1

```

`<`, `>`, `<=`, `>=`는 모양에서 보시면 알 수 있겠지만 부등호에서 유래한 비교 연산자들입니다. 연산자에 따라 좌항이나 우항이 반대편보다 크거나, 또는 같으면 결과값이 1이, 아니면 0이 되는 것을 확인할 수 있습니다. `==`는 양변의 식의 결과값이 같으면 결과값이 1, 같지 않으면 0이 되는 연산자입니다. 반대로, `!=`는 양변의 식의 결과값이 같지 않으면 결과값이 1, 같으면 결과값이 0이 되는 연산자입니다.

비교 연산자는 산술 연산자보다 우선순위가 낮고, 논리 연산자보다 높습니다. 그래서 식 `1 + b < 3 * 5 && 6 != c / 4`는 `(((1 + b) < (3 * 5)) && (6 != (c / 4)))`로 번역됩니다.

## 조건문(conditional statement)

`조건문(conditional statement)`은 결과값이 논리값인 식이 주어졌을 때, 그 식의 결과에 따라 다른 문장을 수행하는 문장입니다. C에선 `if-else문(if-else statement)`이 유일한 조건문입니다. 다음 예제를 봐주세요.

```c
#include <stdio.h>

int main()
{
    if (3 < 5)
    {
        printf("true: ");
        printf("3 is smaller than 5\n");
    }
    else
    {
        printf("false: ");
        printf("3 is not smaller than 5\n");
    }

    if (4 == 6)
    {
        printf("true: ");
        printf("4 is equal to 6\n");
    }
    else
    {
        printf("false: ");
        printf("4 is not equal to 6\n");
    }
}
```
```
true: 3 is smaller than 5
false: 4 is not equal to 6

```

`int main() { ... }` 처럼 `{}`안에 문장을 또 넣을 수 있는 새로운 문법이 등장했습니다. [5장](../5-basic-operators)에서 `int main`안에는 항상 **문장**이 들어가야 한다는 것을 배웠습니다. `if-else statement`라는 이름에서 알 수 있듯, `if-else문`은 여러 문장을 조합해서 하나의 문장(statement)을 만들 수 있는 방법 중 하나입니다. 

if-else문의 구조는 `int main() { ... }`과 전체적으로 비슷한데, `if (...)` 안에 논리값으로 해석되는 식이 들어간다는 점이 다릅니다. 이 식의 결과가 참이면 `if () { ... }`안에 들어있는 문장이, 거짓이면 `else { ... }`안에 들어있는 문장이 실행되게 됩니다.

`if`나 `else` 다음의 `{ ... }` 안에 들어있는 문장이 하나이면, `{}`를 생략할 수 있습니다.

```c
#include <stdio.h>

int main()
{
    int i; scanf("%d", &i);
    if (1 <= i && i <= 10)
        printf("i is between 1 and 10");
    else
        printf("i is not between 1 and 10");
}
```
```
: 5
i is between 1 and 10
```
```
: 12
i is not between 1 and 10
```

> `1 <= i && i <= 10`이라고 적은 것에 주목해주세요. `1 <= i`의 결과는 논리값입니다. `i <= 10`도 마찬가지이고요. `i`가 1과 10 사이에 있으면 1, 아니면 0이 되는 식을 만들고 싶으면 `1 <= i && i <= 10`이라고 적어야 합니다. `1 <= i <= 10`은 `(1 <= i) <= 10`으로 해석되기 때문에, `i`가 1 미만이라고 해도 `0 <= 10`, `i`가 10을 초과해도 `1 <= 10`이 되어 항상 참인 식이 됩니다. **비교 연산자의 결과는 논리값**이라는 것을 항상 기억해주세요.

> `int main() { ... }`의 `{}`는 생략 불가능합니다.

if-else문에선 `{ ... }` 안의 문장이 하나도 없으면, `{}`를 생략할 수 없습니다. 다음 예제는 컴파일되지 않습니다.

```c
#include <stdio.h>

int main()
{
    if (1)
    else
    {
        printf("This is useless");
    }
}
```

`else { ... }` 안의 문장이 하나도 없으면 `else {}` 자체를 생략할 수 있습니다. 원래 if-else문의 이름은 if문이지만, 이런 성질 때문에 두 이름이 혼용됩니다.

```c
#include <stdio.h>

int main()
{
    if (1)
    {
        printf("Foo\n");
    }
    printf("Bar\n");
}
```
```
Foo
Bar

```

> 식 `1`을 논리값으로 해석하면 참이기 때문에 if문의 조건식으로 `1`을 사용하면 `if () { ... }` 안의 문장들은 항상 실행됩니다.

if문은 그 자체로 문장이고, if문 안에는 문장이 들어가기 때문에 if문 여러개를 겹쳐 쓸 수도 있습니다.

```c
#include <stdio.h>

int main() {
    int i; scanf("%d", &i);
    if (i < 0)
        printf("i is smaller than 0");
    else {
        if (i <= 10)
            printf("i is between 0 and 10");
        else
            printf("i is bigger than 10");
    }
}
```
```
: -2
i is smaller than 0
```
```
: 7
i is between 0 and 10
```
```
: 15
i is bigger than 10
```

if-else문 자체는 하나의 문장이기 때문에, 위 문장은 다음과 같이도 쓸 수 있습니다.

```c
#include <stdio.h>

int main() {
    int i; scanf("%d", &i);
    if (i < 0)
        printf("i is smaller than 0");
    else if (i <= 10)
        printf("i is between 0 and 10");
    else
        printf("i is bigger than 10");
}
```